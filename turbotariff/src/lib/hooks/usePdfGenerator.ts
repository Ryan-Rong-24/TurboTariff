import { useState, useEffect } from 'react';
import { useStore } from '../store';
import { toast } from 'react-hot-toast';
import { generateTariffForm } from '../api';

interface PdfOptions {
  includeInsights?: boolean;
  includeImages?: boolean;
  format?: 'A4' | 'Letter';
  orientation?: 'portrait' | 'landscape';
}

interface GeneratedPdf {
  url: string;
  itemId: string;
}

export function usePdfGenerator() {
  const [generating, setGenerating] = useState(false);
  const [generatedPdfs, setGeneratedPdfs] = useState<GeneratedPdf[]>([]);
  const { currentPackingList } = useStore();
  
  // Clear PDFs when the packing list changes
  useEffect(() => {
    setGeneratedPdfs([]);
  }, [currentPackingList?.id]);

  const generatePdf = async (options: PdfOptions = {}) => {
    if (!currentPackingList) {
      toast.error('No packing list selected');
      return null;
    }

    if (!currentPackingList.items || currentPackingList.items.length === 0) {
      toast.error('Packing list has no items');
      return null;
    }

    try {
      setGenerating(true);
      
      // Call the API to generate PDFs for all items in the packing list
      console.log('Generating PDFs for items:', currentPackingList.items);
      
      // Ensure items have all necessary tariff rate fields before sending to API
      const processedItems = currentPackingList.items.map(item => {
        // Calculate IRC rate (combine IEEPA and Reciprocal if available)
        let ircRate = '145'; // Default combined rate
        if (item.ieepa_rate !== undefined && item.reciprocal_rate !== undefined) {
          const ieepRate = parseFloat(item.ieepa_rate) || 0;
          const recipRate = parseFloat(item.reciprocal_rate) || 0;
          ircRate = (ieepRate + recipRate).toString();
        } else if (item.other_rate) {
          ircRate = item.other_rate;
        } else if (item.ircRate) {
          ircRate = item.ircRate;
        }
        
        // Set all values with appropriate defaults
        return {
          ...item,
          // A. HTSUS Rate (Basic Duty Rate)
          basic_duty_rate: item.basic_duty_rate || item.generalRate || item.general_rate || '0',
          
          // B. AD/CVD Rate (Section 301)
          section_301_rate: item.section_301_rate || item.adcvdRate || item.section301_rate || '20',
          
          // C. IRC Rate (IEEPA + Reciprocal)
          other_rate: ircRate,
          
          // Store individual rates if available
          ieepa_rate: item.ieepa_rate || '20', // Default IEEPA rate
          reciprocal_rate: item.reciprocal_rate || '125', // Default Reciprocal rate
        };
      });
      
      const response = await generateTariffForm({
        items: processedItems
      });

      if (response.data?.success) {
        console.log('PDF generation successful, response:', response.data);
        const pdfs = response.data.pdfs || [];
        
        if (pdfs.length > 0) {
          setGeneratedPdfs(pdfs);
          toast.success(response.data.message || 'PDFs generated successfully');
          return pdfs;
        } else {
          // Handle case where API reports success but no PDFs were returned
          console.error('API reported success but no PDFs were returned');
          toast.error('No PDFs were generated by the server');
          
          // Check if there might be a default form available
          if (response.data.pdfUrl) {
            const defaultPdf = [{
              url: response.data.pdfUrl,
              itemId: currentPackingList.items[0]?.id || 'default'
            }];
            setGeneratedPdfs(defaultPdf);
            return defaultPdf;
          }
          
          return null;
        }
      } else {
        console.error('PDF generation failed:', response.error);
        throw new Error(response.error || 'Failed to generate PDFs');
      }
    } catch (error) {
      console.error('Error generating PDFs:', error);
      toast.error(typeof error === 'string' ? error : 'Failed to generate PDFs');
      
      // Try to provide a fallback
      if (generatedPdfs.length > 0) {
        return generatedPdfs;
      }
      
      return null;
    } finally {
      setGenerating(false);
    }
  };

  const downloadAllPdfs = async (options: PdfOptions = {}) => {
    // First check if we already have PDFs
    if (generatedPdfs.length > 0) {
      window.open(generatedPdfs[0].url, '_blank');
      
      if (generatedPdfs.length > 1) {
        toast.success(`${generatedPdfs.length} PDFs available. Opening the first one. Others can be accessed from the dashboard.`);
      }
      return;
    }
    
    // Otherwise generate new PDFs
    const pdfs = await generatePdf(options);
    if (pdfs && pdfs.length > 0) {
      window.open(pdfs[0].url, '_blank');
      
      if (pdfs.length > 1) {
        toast.success(`${pdfs.length} PDFs generated. Opening the first one. Others can be accessed from the dashboard.`);
      }
    } else {
      // Fallback - try to direct link to the default completed form
      try {
        window.open('/output/completed_form.pdf', '_blank');
      } catch (e) {
        console.error('Failed to open fallback PDF');
        toast.error('Failed to generate or open PDF');
      }
    }
  };

  const downloadPdf = async (itemId: string, options: PdfOptions = {}) => {
    // Check if we already have the PDF for this item
    if (generatedPdfs.length === 0) {
      await generatePdf(options);
    }
    
    const pdf = generatedPdfs.find(p => p.itemId === itemId);
    if (pdf) {
      window.open(pdf.url, '_blank');
    } else {
      // If we can't find the specific PDF, try opening any available PDF
      if (generatedPdfs.length > 0) {
        window.open(generatedPdfs[0].url, '_blank');
        toast.warning(`PDF for item ${itemId} not found. Opening an alternative PDF.`);
      } else {
        toast.error(`No PDFs found for any items.`);
        // Fallback - try the default
        try {
          window.open('/output/completed_form.pdf', '_blank');
        } catch (e) {
          console.error('Failed to open fallback PDF');
        }
      }
    }
  };

  const previewPdf = async (itemId?: string, options: PdfOptions = {}) => {
    if (!itemId && generatedPdfs.length > 0) {
      // If no specific item requested but we have PDFs, show the first one
      window.open(generatedPdfs[0].url, '_blank');
      return;
    }
    
    // If we need to generate PDFs
    if (generatedPdfs.length === 0) {
      const pdfs = await generatePdf(options);
      
      if (!pdfs || pdfs.length === 0) {
        toast.error('Failed to generate PDFs');
        // Try fallback
        try {
          window.open('/output/completed_form.pdf', '_blank');
        } catch (e) {
          console.error('Failed to open fallback PDF');
        }
        return;
      }
      
      if (itemId) {
        const pdf = pdfs.find(p => p.itemId === itemId);
        if (pdf) {
          window.open(pdf.url, '_blank');
        } else {
          // If specific item not found, open the first one
          window.open(pdfs[0].url, '_blank');
          toast.info('Specific item PDF not found, opening the first available PDF');
        }
      } else {
        // If no specific item requested, open the first one
        window.open(pdfs[0].url, '_blank');
      }
    } else {
      // We already have PDFs
      if (itemId) {
        const pdf = generatedPdfs.find(p => p.itemId === itemId);
        if (pdf) {
          window.open(pdf.url, '_blank');
        } else {
          // If specific item not found, open the first one
          window.open(generatedPdfs[0].url, '_blank');
          toast.info('Specific item PDF not found, opening the first available PDF');
        }
      } else {
        // If no specific item requested, open the first one
        window.open(generatedPdfs[0].url, '_blank');
      }
    }
  };

  return {
    generating,
    generatedPdfs,
    generatePdf,
    downloadPdf,
    downloadAllPdfs,
    previewPdf,
  };
}